1.Java SE核心部分主要有四个:
	1.面向对象
	2.类集框架
	3.IO操作
	4.Java数据库操作(JDBC)

2.1一个简单的例子
	需要注意的是:如果将一个类声明成public,则也要将文件名称取成和这个类一样的名称.

4.1.1声明常量的语法为:
	final 数据类型 常量名称[=值]
5.1.八种数据类型
1.数据类型:基本数据类型和引用数据类型.
	1.1.基本数据类型:数值型,布尔型,字符型
		1.1.1.数值型:整数型,浮点型
			1.1.1.1.整数型:byte,short,int,long
			1.1.1.2.浮点型:float,double
		1.1.2.布尔型:boolean
		1.1.3.字符型:char
	1.2.引用数据类型:类(class),接口(interface),数组(array)
5.2.浮点类型
double类型:共8个字节,64位,第一位为符号位,中间11位表示指数,最后52位表示尾数.
float类型:共4个字节,32位,第一位为符号位,中间8位表示指数,最后23位表示尾数.
5.3.字符类型
	常用转义字符:
	转义字符	所代表的意义	转义字符	所代表的意义
	\f			换页			\\			反斜杠
	\b			倒退一格		\'			单引号
	\r			归位			\"			双引号
	\t			跳格			\n			换行
5.5.数据类型的转换
1.1.数据类型的转换方式可分为"自动类型转换"及"强制类型转换"两种.
1.2.自动类型转换
	1.2.1).转换前的数据类型与转换后的数据类型兼容
	1.2.2).转换后的数据类型的表示范围比转换前的类型大.

6.1.运算符(赋值运算符,一元运算符,)
	程序是由许多语句组成的,而语句的基本单位就是表达式和运算符.
	Java的运算符可分为4类:算术运算符,关系运算符,逻辑运算符和位运算符.
	表达式由操作数与运算符组成.操作数可以是常量,变量,也可以是方法.而运算符就是数学中的运算符号.
	运算符:
		1).赋值运算符
		2).一元运算符
		3).算术运算符
		4).关系运算符
		5).递增与递减运算符
		6).逻辑运算符
		7).括号运算符
		8).条件运算符
	表达式:
		1).算术表达式:算术表达式用于数值计算,由算术运算符和变量或常量组成,其结果是一个数值.例如(a*b)
		2).关系表达式:关系表达式常用于程序判断语句中,由关系运算符组成,其运算结果为逻辑型.例如(a > b)
		3).逻辑表达式:逻辑表达式是由逻辑运算符组成的表达式,其结果也是逻辑型.例如((1 > 2) && (3 == 3))
		4).条件表达式:条件表达式由运算符"? :"组成,其基本形式为a?x:y,如果a值为非0,则整个表达式的值为x,否则为y.
		5).赋值表达式:赋值表达式由赋值运算符和操作数组成,赋值运算符用于给变量赋值.
	表达式的类型转换规则:
	1).占用字节少的类型会转换为占用字节多的类型
	2).char类型会转换为int类型
	3).int类型会转换为float类型
	4).表达式中两个操作数有一个是double,则另一个会转换为double类型.
	5).boolean不能转换为其他类型.
7.1 程序的结构设计
	程序的结构包含:1).顺序结构.2)选择结构.3).循环结构.
	选择结构提供了两种类型的分支结构:1).条件分支.2).开关分支.
9.1 过程是编程语言:程序=算法+数据,面向对象编程语言为:程序=对象+消息.
    所有的面向对象编程语言都支持3个概念:封装,多态性和继承.
    对象的特征分为静态特征和动态特征两种.
    面向对象的程序设计有以下3个主要特征:1).封装性.2).继承性.3).多态性.
    Java语言中含有方法重载与成员覆写两种形式的多态.

	类中的属性和方法都是类中的成员(成员变量和成员方法),成员覆写有属性覆写和方法覆写:
	1).重载:方法名称相同,但却可在不同的场合做不同的事.
	2).覆写:当一个子类继承一个父类,而子类中的方法与父类中的方法的名称,参数个数,类型等都完全一直时,
		 就称子类中的这个方法覆写了父类中的方法.同理,如果子类中重复定义了父类中已有的属性,则称
		 此子类中的属性覆写了父类中的属性.
9.2.1 类的声明语法如下:
    +--------------------+
    | class 类名称       |
    | {                  |
    |     //类的成员变量 |
    |     //类的方法     |
    | }                  |
    +--------------------+
9.2.2 类的定义语法如下:
    +---------------------------------------------------+
    |   class 类名称                                    |
    |   {                                               |
    |       数据类型    属性;                           |
    |                                                   |
    |       返回值数据类型  方法名称(参数1, 参数2, ...) |
    |       {                                           |
    |           程序语句;                               |
    |           return 表达式;                          |
    |       }                                           |
    |                                                   |
    |   }                                               |
    +---------------------------------------------------+
9.3 创建属于某类的对象,需要通过下面两个步骤实现:
    1).声明指向"由类所创建的对象"的变量
    2).利用new创建新的对象,并指派给先前所创建的变量.
9.3.3 对象的比较
	有两种方式可用于对象间的比较,即"=="运算符与equals()方法.
	"=="运算符用于比较两个对象的内存地址值是否相等,equals()
	方法用于比较两个对象的内容是否一致.
9.3.4 对象数组的使用步骤:
	1).声明类类型的数组变量,并用new分配内存空间给数组.
	2).用new产生新的对象,并分配内存空间给它.
9.4 类的基本组成部分包含属性和方法.
9.4.1 类变量(就是静态变量,另一种叫法而已)和成员变量的区别在于:类变量就是static修饰的变量.它们被
	类的实例所共享,就是说一个实例改变了这个值,其他的实例也会受到影响;
	成员变量则是实例所私有的,只有实例本身可以改变它的值.
	
	非静态内部类不能定义静态属性,静态方法和静态内部类
9.4.2 Java类属性和对象属性的初始化顺序如下:
	1).类属性(静态变量)定义时的初始化.
	2).static块中的初始化代码.
	3).对象属性(非静态变量)定义时的初始化.
	4).构造方法(函数)中的初始化代码.
10.3.2 super关键字不仅可用于调用父类中的构造方法,也可用于调用父类中的属性或方法.
	例如下面的格式:
	1)super.父类中的属性
	2)super.父类中的方法();
11.3.接口的结构:1).接口里的数据成员必须初始化,且数据成员均为常量.
				2).接口里的方法必须全部声明为abstract,也就是说接口
				不能像抽象类一样保有一般的方法.必须全部是"抽象方法"
11.4.接口是Java实现多继承的一种机制,一个类智能继承一个父类,但如果需要一个类继承多个父类,
	就明显无法实现,所以就出现了接口的概念.
	一个类只可以继承一个父类,但却可以实现多个接口.
	接口的扩展(继承)也是通过关键字extends来实现的.有趣的是,一个接口可以继承多个接口,
	这点与类的继承有所不同.
12.2.1.		Outer.Inner inner = outer.new Inner();
	外部类中的内部类可以理解为是外部类的成员变量(例如 int score = 95);
	Outer.Inner(相当于int,一个属性的类型而已,outer.是通过Outer类的对象(outer)访问其属性而已)
12.2.2.在方法中定义的内部类只能访问方法中的final类型的局部变量,因为用final定义的局部变量相当于一个常量,它的生命周期超出方法运行的生命周期,
13.2.String类和StringBuffer类:
	String类对象的内容一旦被初始化就不能再改变.
	StringBuffer类用于内容可以改变的字符串.
13.3.基本数据类型包装类:
	Integer类中的parseInt()方法,将一个字符串解析成基本数据类型.
13.4.System类和Runtime类
	13.4.1 System类:
		exit(int status):提前终止虚拟机运行.
		CurrentTimeMillis():返回自1970年1月1日0点0分0秒起至今的以毫秒为单位的时间.
		getProperties():获取当前虚拟机的环境属性.
	13.4.2 Runtime类
		getRuntime():获取正在运行的Runtime对象的引用.
13.5.Date与Calendar,DateFormat类
14.1.1.javac -d . TestPackage1.java
	"-d":	表示生成目录.
	".":	表示在当前目录下生产.
	这样就会在当前目录下生成一个demo文件夹,在demo文件夹下就会生成一个java文件夹(在源代码中有package demo.java),在此文件夹下会有编译好的Person.class和TestPackage1.class,编译好之后用下面的语法来执行它.java demo.java.TestPackage1
14.4. jar -cvf create.jar demo
	-c:	创建新的文档
	-v:	生成详细输出到标准输出上
	-f:	指定存档文件名
	create.jar	是生成jar文件的名称
	demo:	到打成jar文件的包
15.1.几种常见的异常:
	1).算术异常
	2).空指针异常
	3).找不到文件异常
15.3.抛出异常的方式有以下两种:
	1)程序中抛出异常:throw 异常类实例对象;
	2)指定方法抛出异常:方法名称(参数...) throws 异常类1,异常类2,...
16.2.1.ArrayList类扩展AbstractList并实现List接口.ArrayList支持可随需要而增长的动态数组.
16.2.2.LinkedList类扩展了AbstractSequentialList并实现了List接口.它提供了一个链接列表的数据结构.
16.2.3.HashSet扩展AbstractSet并实现Set接口.它创建一个类集,该列集使用散列表进行存储,而散列表则通过使用称之为散列法的机制来存储信息.
16.2.4.TreeSet为使用树来进行存储的Set接口提供了一个工具,对象按升序排列.访问和检索是很快的.在存储了大量的需要进行快速检索的排序信息的情况下,TreeSet是一个很好的选择.
16.3.Iterator可以通过循环输出类集单元,从而获得或删除元素.
	 ListIterator扩展了Iterator,允许双向遍历列表,并且可以修改单元.
	
	使用迭代方法通过循环输出类集内容,具体操作步骤如下:
	1).通过调用类集的iterator()方法获得对类集的迭代方法.
	2).建立一个调用hasNext()方法的循环,只要hasNext()返回true,就进行循环迭代.
	3).在循环内部,通过调用next()方法来得到每一个元素.
19.2.如果在类里要激活线程,必须先做好下面两个准备.
	1).线程必须扩展自Thread类,使自己成为它的子类.
	2).线程的处理必须编写在run()方法内.
19.2.3.实现了Runnable 接口相对于继承Thread类来说,有如下几个优势:
	1).适合多个相同程序代码的线程去处理同一资源的情况.
	2).可以避免由于Java的单继承特性带来的局限.
	3).增强了程序的健壮性,代码能够被多个线程共享,代码与数据是独立的.
19.3.每个线程都有5个状态:创建,就绪,运行,阻塞,终止.
19.6.2.Java通过Object类的wait,notify,notifyAll这几个方法来实现线程间的通信的.
19.7.通过控制run方法中循环条件的方式来结束一个线程的方法是值得推荐使用的方法,这也是实际中用的最多的方法.
20.3.5.Java定义了两个特殊的流对象:1).System.in(代表键盘).2).System.out(代表显示器);
22.1.Socket介绍
	1).Socket是网络上运行的两个程序间双向通讯的一端,它既可以接收请求,
	 也可以发送请求,利用它可以较为方便地实现网络上数据的传递.
	2).在Java中,可以将Socket理解为客户端或者服务器端的一个特殊的对象,
	这个对象有两个关键的方法,一个是getInputStream()方法,另一个是getOutputStream()方法.
	getInputStream()方法用于得到一个输入流,客户端的Socket对象上的getInputStream()
	得到的输入流其实就是从服务端发挥的数据流.getOutputStream()方法用于得到一个输出流,
	客户端Socket对象上的getOutputStream()方法返回的输出流就是将要发送到服务器端的数据流.
	3).Socket有两种主要的操作方式:面向连接(电话)和无连接(邮递).
*带buffer就是转换流

	

	
























