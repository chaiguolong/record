1: 将终端的背景色设置成被色,文本设置成黑色.
	setterm -inversescreen on./使用off可以关闭此特性.	
2: 查看系统上运行的所有进程.
	ps -ef	#-e:参数指定显示所有运行在系统上的进程
			#-f:参数则扩展了输出.
3: df查看磁盘的存储空间,du命令查看的是某个特定目录的磁盘使用情况.
	du命令的参数如下:
	-c: 显示所有已列出文件总的大小
	-h: 按用户易读的格式输出大小
	-s: 显示每个输出参数的总计
4. 要想将命令置入后台模式,可以在命令默默为加上字符&.
	jobs命令可以显示出当前运行在后台模式中的所有用户的进程.
5. 协程可以同时做两件事.它在后台生成一个子shell,并在这个子
	shell中执行命令.
	例子: coproc sleep 10
6. 命令历史记录被保存在隐藏文件.bash_history中,它位于用户的主目录中.
	这里要注意的是:bash命令的历史记录是先存放在内存中,当shell退出是
	才被写入到历史文件中.要实现强制写入,需要使用history命令-a选项.
	跨终端也可.但是对于其他打开的终端会话,历史记录并不会更新.
	这是因为.bash_history文件只有在代开收个终端会话时才会被读取.要
	想强制读取.bash_history文件.更新终端会话的历史记录,可以使用history
	-n 命令.
7. 所有的环境变量名均使用大写字母,这是bash shell的标准管理.如果
	是你自己创建的局部变量伙食shell脚本,请使用小写字母.变量名区
	分大小写.在涉及用户定义的局部变量时坚持使用小写字母,这能够
	便面重复定义系统环境变量可能带来的灾难.
8. 记住,变量名,等号和值之间没有空格,这一点非常重要.如果在赋值表达
	式中加了空格,bash shell就会把值当成一个单独的命令.
	例如: 
	$ my_variable = "Hello World" 
	-bash: my_variable: command not found
9. 顾名思义,局部环境变量只能在定义它们的进程中可见.子shell中定义的在
	父shell中不能使用,相反也一样.
10. 设置全局环境变量的方法是先创建一个局部环境变量,然后再把它导出
	到全局环境中.这个过程通过export命令来完成.变量名前面不需要加$.
11. 修改子shell中全局环境变量并不会影响到父shell中该变量的值,子shell
	甚至无法使用export命令改变父shell中全局环境变量的值.
12. 删除已经存在的环境变量,可以使用unset命令完成这个操作,记住不要使用$.
13. 在涉及环境变量时,什么时候该使用$,什么时候不该使用$,实在让人摸不
	着头脑.记住一点就行了: 如果要用到变量,使用$;如果要操作变量,不使用$.
	这条规则的一个例外就是使用printenv显示某个变量的值.	
14. 在处理全局环境变量时,事情就有点棘手了.如果你是在子进程中删除
	了一个全局环境变量,这只对子进程有效.该全局环境变量在父进程中
	依然可用.和修改变量一样,在子shell中删除全局变量后,你无法将效
	果反映到父shell中.
15. 环境变量可以作为数组使用:
	$ mytest=(one two three four five)
	$ echo $mytest 
	one
	$
	$ echo ${mytest[2]} 
	three
	$
16. useradd命令的系统默认值被设置在/etc/default/useradd文件中.
	useradd命令不会创建HOME目录,但是-m(home)命令行选项会使其
	创建HOME目录.
17. 如果你想从系统中删除用户,userdel可以满足这个需求.默认情况下,
	userdel命令只会删除/etc/passwd文件中的用户信息,而不会删除系
	统中属于该账户的任何文件.
18. 如果加上-r参数,userdel会删除用户HOME目录以及邮件目录.然后,系
	统上扔可能有已删除用户的其他文件.这在有些环境中会造成问题.
19. 在有大量用户的环境中使用-r参数时要特别小心.你永远不知道用户
	是否在其HOME目录下存放了其他用户或其他程序要使用的重要文件.
	记住,在删除用户的HOME目录之前一定要检查清除.
20. usermod命令:
	.-l修改用户账户的登陆名
	.-L锁定账户,使用户无法登陆
	.-p修改账户的密码.
	.-U解除锁定,使用户能够登陆
	-L选项尤其有用.它可以将账户锁定,使用户无法登陆,同时无需删除账户
	和用户数据.要让账户恢复正常,只要用-U选项就行了.
21. /etc/group文件有4个字段:
	.组名
	.组密码
	.GID
	.属于该组的用户列表
	千万不能通过直接修改/etc/group文件来添加用户到一个组,要通过usermod
	命令.在添加用户到不同组之前,首先得创建组.
	注意:用户账户列表某种意义上有些误导人.你会发现,在列表中,有些组
	并没有列出用户,这并不是说这些组没有成员.当一个用户在/etc/passwd
	文件中指定某个组作为默认组时,用户账户不会作为该组成员再出现在/etc
	/group文件中.
22. groupmod命令可以修改已有组的GID(加-g选项)或组名(加-n选项)
	修改组名时,GID和组成员不会改变,只有组名改变.由于所有的安全
	权限都是基于GID的,你可以随意改变组名而不会影响文件的安全性.
23. 使用文件权限符

	-rw-r--r--  1 develop  staff     0B Jul 21 09:32 file1
	输出结果的第一个字段就是描述文件和目录权限的编码.
	这个字段的第一个字符代表了对象的类型
		> -代表文件
		> d代表目录
		> l代表链接
		> c代表字符型设备
		> b代表块设备
		> n代表网络设备
		之后有3组三字符的编码.每一组定义了3种访问权限:
		> r代表对象是可读的
		> w代表对象是可写的
		> x代表对象是可执行的
		若没有某种权限,在该权限位会出现单破折线.这3组权限分别对应
		对象的3个安全级别:
		> 对象的属主
		> 对象的属组
		> 系统其它用户
	
24. 符号模式的权限设置:[ugoa] [+-=] [rwxXstugo...]
	第一组字符定义了权限作用的对象:
	> u代表用户
	> g代表组
	> o代表其他
	> a代表上述所有
	后面跟着的符号表示:
	> +在现有权限上增加权限
	> -在现有权限上移除权限
	> =将权限设置成后面的值
	第三个符号表示作用到设置上的权限(这个值要比通常的rwx多):
	> X:如果对象是目录或者它已有执行权限,赋予执行权限
	> s:运行时重新设置UID或GID
	> t:保留文件或目录
	> u:将权限设置为跟属主一样
	> g:将权限设置为跟属组一样
	> o:将权限设置为跟其他用户一样

25. ls命令的-F选项,它能够在具有执行权限的文件名后加一个星号.
	在目录后面加斜杠.
26. linux系统上共享文件的方法是创建组.
27. 如果系统出现损坏的包依赖关系,可以使用yum clean all命令.
	然后试着用yum命令的update选项.
28. 用户变量:使用等号将赋值给用户变量.
	注意:在变量,等号和值之间不能出现空格(一个困扰初学者的用法)
29. 变量每次被引用时,都会输出当前赋给它的值.
	重要的是要记住,引用一个变量值时需要使用美元符,
	而引用变量来对其进行赋值时则不要使用美元符.
30. 命令替换:$()和(`):shell脚本中最有用的特性之一就是可以
	从命令输出中提取信息,并将其赋给变量.
31. 执行数学运算,使用方括号$[],bash shell数学运算只支持整数运算,
	zsh提供了完整的浮点数算术操作.
32. 查看退出状态码:linux提供了一个专门的变量$?来保存上一个已执
	行命令的退出状态码.
33. if-then语句只能测试命令退出状态码的条件.test命令提供了在if-then
	语句中测试不同条件的途径.
34. test命令可以判断三类条件: 1.数值比较 2.字符串比较 3.文件比较
35. 双方括号[[  ]]和单方括号[  ]的区别: 双方括号提供了针对字符串
	比较的高级特性. 提供了test未提供的另一个特性--模式匹配(也就是正则表达式).
	注意:双方括号在bash shell中工作良好,不过要小心,不是所有的shell
	都支持双方括号.
36. bash shell只能处理整数,不能处理(计算比较等等)小数,仅仅能显示小数.
37. 如果用test[ condition ]测试字符串顺序,有两个问题需要注意:
	1. 大于号和小于号必须转义,否则shell会把它们当做重定向符号,把字符串
		值当做文件名
	2. 大于和小于顺序和sort命令所采用的不同.
38. test命令和测试表达式使用标准的数学比较符号(>/</=)来表示字符串比较,
	而用文本代码(-eq/-gt/-lt)来表示数值比较.
39. 检查空文件: 应该用-s(size)比较来检查文件是否为空,尤其是在不想删	   除非空文件的时候.
40. bash shell提供if-then的高级特性:
	1. 用于数学表达式的双括号
		(在数学表达式中的大于号无需转义:例如: 
			"((  $val1 ** 2 > 90 ))")
	2. 用于高级字符串处理功能的双方括号.
41. for var in list
	do
		commands
	done
	中的$var在最后一次迭代后,它的值会在shell脚本的剩余部分
	一直保持有效.它会一直保持最后一次迭代的值(除非你修改了它)
42. 在改变IFS之前保存原来的IFS值,之后再回复它.
	IFS_OLD=$IFS
	IFS=$'\n'
	<在代码中使用心得IFS值>
	IFS=$IFS_OLD
	如果要指定多个IFS字符,只要将他们在赋值行串起来就行.
	IFS=$'\n':;"
43. 在linux中目录名和文件名中包含空格是合法的.所以在引用
	变量时需要将$file用双引号圈起来("$file")
44. C语言风格的for循环有些部分并没有遵循bash shell标准的for命令:
	for (( a = 1; a < 10; a++ ))
	1. 变量赋值可以有空格
	2. 条件中的变量不以美元符开头
	3. 迭代过程的算式魏永expr命令格式.
45. while(until)命令允许你在while(until)语句行定义多个测试命令,
	只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环.
46. 位置参数变量是标准的数字: $0是程序名,$1是第一个参数,
	$2是第二个参数,依次类推,直到第九个参数$9
47. 如果脚本需要的命令行参数不止9个,你仍然可以处理,
	但是需要稍微修改一下变量名.在第9个变量之后,
	你必须在变量数字周围加上花括号,比如${10}
48. basename命令会返回不包含路径的脚本名
49. 如果你仔细考虑过,可能会觉得既然$#变量含有参数的总是,
	那么变量${$#}就代表了最后一个命令行参数变量,实际上需要{}中不能	使用美元符,必须将美元符换成感叹号.很奇怪,但的确管用.
50. $*和$@变量可以用来轻松访问所有的参数,这两个变量都能够
	在单个变量中存储所有的命令行参数.
	1.  $*变量会将命令行上提供的所有参数当做一个单词保存.
	    这个单词包含了命令行中出现的每一个参数值.基本上$*变量会将
	    这些参数视为一个整体,而不是多个个体.
	2.  $@变量会将命令行上提供的所有参数当做同一字符串中的多个
		独立的单词.这样你就能够遍历所有的参数值,得到每个参数.
	
51. shift命令: 默认情况下它会将每个参数变量向左移动一个位置.
	所以,变量$3的值会移到$2中,变量$2的值会移到$1中,而变量$1
	的值会被删除(注意:变量$0的值,也就是程序名,不会改变).
	注意:使用shift命令的时候要小心.如果某个参数被移除,它的值
	就被丢弃了,无法在恢复.
52. 对linux来说,这个特殊字符就是双破折线(--).shell会用双破折线
	来表明选项列表结束.
53. set命令的选项之一是双破折线(--),它会将命令行参数
	替换成set命令的命令行值.






















