#+startup: overview
* Linux_shell脚本攻略
** 第一章 小试牛刀
*** 1.1简介
**** 1).#!/bin/bash(shebang)
**** 2).有两种运行脚本的方式
1. 将脚本作为sh的命令行参数.
   #+begin_src bash
     sh script.sh
   #+end_src
   #+begin_src bash
     sh /home/path/script.sh
   #+end_src
2. 将脚本作为具有执行权限的可执行文件.
3. 如果将脚本作为sh的命令行参数来运行,那么脚本中的shebang行也就没有什么用处了.
4. 为了是shell脚本能够自己独立运行,需要具备可执行权限.要使脚本独立运行,必须利用shebang行.
   它通过使用位于#!之后的解释器来运行脚本.至于脚本的可执行权限,可以通过下方设置:
   #+begin_src bash
     chmod a+x script.sh
   #+end_src
5. Bash还维护了一个历史记录文件~/.bash_history.
6. 在Bash中,每个命令伙食命令序列是通过使用分号或换行符来分隔的.比如:
   $ cmd1;cmd2
   它等同于:
   $ cmd1
   $ cmd2
*** 1.2终端打印
**** 1.2.1实战演练
1. echo是用于终端打印的基本命令.在默认情况下,echo在每次调用后会添加一个换行符.
   #+begin_src bash
     echo "Welcome to Bash"
   #+end_src

   #+RESULTS:
   : Welcome to Bash
   只需要使用带双引号的文本,结合echo命令就可以将文本在终端中打印出来.
   类似的,不带双引号的文本也可以得到相同的输出结果:
   #+begin_src bash
     echo Welcome to Bash
   #+end_src

   #+RESULTS:
   : Welcome to Bash
   使用单引号也可以完成相同的任务:
   #+begin_src bash
     echo 'Welcome to Bash'
   #+end_src

   #+RESULTS:
   : Welcome to Bash
   这些方法看起来相似,但各有一些特殊用途和副作用.
   思考下面这行命令:
   #+begin_src bash
     echo "cannot include exclamation - ! within double quotes"
   #+end_src

   #+RESULTS:
   : cannot include exclamation - ! within double quotes
   这条命令将会返回:bash: !:event not found error.
   因此,如果你希望打印!,那就不要放入双引号内,或者你可以在其之前加上一个特殊的转义字符(\)将其转义.(这里能成功应该被emacs修改了)
   #+begin_src bash
     echo Hello World!
   #+end_src

   #+RESULTS:
   : Hello World!
   或
   #+begin_src bash
     echo 'Hello World!'
   #+end_src

   #+RESULTS:
   : Hello World!
   或者
   #+begin_src bash
     echo "Hello World \!"
   #+end_src

2. 每种方法的副作用如下:
   - 使用不带引号的echo时,你没法在所要显示的文本中使用,
     因为在bash shell中被用作命令定界符.

   - 以echo hello;hello为例,echo hello被视为一个命令,
     第二个hello则被视为另一个命令.

   - 使用带单引号的echo时,Bash不会对单引号中的变量(如$var)求值,
     而只是照原样显示

     这就意味着:$echo '$var'将会返回$var

3. 另一个用于终端打印的命令是printf
   #+begin_src bash
     printf "Hello world"
   #+end_src

   #+RESULTS:
   : Hello world
   printf并不会像echo命令一样,自动添加换行符,我们必须在需要的时候手动添加.
   比如在下面的脚本中:
   #+begin_src bash
    #!/bin/bash
    #文件名:printf.sh

    printf "%-5s %-10s %-4s\n" No Name Mark

    printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456

    printf "%-5s %-10s %-4.2f\n" 2 James 90.9989

    printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564
   #+end_src

   #+RESULTS:
   | No | Name   |  Mark |
   |  1 | Sarath | 80.35 |
   |  2 | James  |  91.0 |
   |  3 | Jeff   | 77.56 |

   %s,%c,%d,%f都是格式替换符,其所对应的参数可以置于带引号的格式字符串之后.
   
**** 1.2.2补充内容
1. 在echo中转义换行符
   在默认情况下,echo会将衣蛾换行符最佳到输出文本的尾部.
   可以使用标志-n来忽略结尾的换行符.
2. echo同样接收双引号字符串内的转义序列作为参数.如果需要
   使用转义序列,则采用echo -e "包含转义序列的字符串"这种形式.
   例如:
   #+begin_src bash
     echo -e "1\t2\t3"
   #+end_src

   #+RESULTS:
   | 1 | 2 | 3 |

3. 打印彩色输出
   每种颜色都有自己的颜色码.比如:
   重置=0  黑色=30  红色=31  绿色=32  黄色=33
   蓝色=34  洋红=35  青色=36  白色=37
   #+begin_src bash
     echo -e "\e[1;31m This is red text\e[0m"
   #+end_src

   #+RESULTS:
   : \e[1;31m This is red text\e[0m

   \e[1;31将颜色设为红色,\e[0m将颜色重新置回.你只需要将31替换成
   想要的颜色码就可以了.

   要设置彩色背景,经常使用的颜色码是: 
   重置=0  黑色=40  红色=41  绿色=42  黄色=43
   蓝色=44  洋红=45  青色=46  白色=47

   要打印彩色文本需输入:
   #+begin_src bash
     echo -e "\e[1;42m Green Background \e[0m"
   #+end_src

   #+RESULTS:
   : \e[1;42m Green Background \e[0m

*** 1.3. 玩转变量和环境变量
   1. 在Bash中,每一个变量的值都是字符串,无论你给变量赋值
      时有没有使用引号,值都会以字符串的形式存储.
   2. 有一些特殊的变量会被shell环境和操作系统环境用来存
      储一些特别的值,这类变量就被称为环境变量.
**** 1.3.1预备知识
   1. 当一个应用程序执行的时候,它接收一组环境变量.可以使
      用env命令在终端查看所有与此终端进程相关的环境变量.
   2. 对于每个进程,在其运行时的环境变量可以使用下面的命令
      来查看:
      #+begin_src 
	cat /proc/$PID/environ
      #+end_src
      其中,将PID设置成相关进程的ID.
   3. 假设有一个叫做emacs的应用程序正在运行.
      我们可以使用pgrep命令获得emacs的进程ID:
      #+begin_src bash
	pgrep emacs
      #+end_src

      #+RESULTS:
      : 1804
      那么,你就可以通过以下命令获得与该进程相关的环境变量:
      #+begin_src bash
	cat /proc/1804/environ
      #+end_src

      #+RESULTS:
      
      上面介绍的命令返回一个包含环境变量以及对应变量值的列表.
      每个变量以name=value的形式来描述,彼此之间由null字符(\0)
      分割.如果你讲\0替换成\n,那么就可以将输出重新格式化,是的每
      一行显示一堆variable=value.替换可以使用tr命令来实现:
      #+begin_src bash
	cat /proc/1804/environ | tr '\0' '\n'
      #+end_src

      #+RESULTS:

**** 1.3.2实战演练
   1. 一个变量可以通过一下方式进行赋值:
      var=value
      var是变量名,value是赋给变量的值.如果value不包含任何
      空白字符(例如空格),那么它不需要使用引号进行引用,反之
      则必须使用单引号或双引号.
      注意: var=value(赋值操作);而var = value(相等操作)
      等号两边不应该出现空格,如果是赋值操作的话.

   2. 在变量名之前加入$前缀就可以打印出变量的内容:
      #+begin_src bash
	var="value" #给变量var赋值
	echo $var
	#或者
	echo ${var}
      #+end_src

      #+RESULTS:
      | value |
      | value |
      
      我们可以在printf或echo命令的双引号引用变量值.
      #+begin_src bash
	#!/bin/bash
	#文件名:variables.sh
	fruit=apple
	count=5
	echo "We have $count ${fruit}(s)"
      #+end_src

      #+RESULTS:
      : We have 5 apple(s)

   3. 环境变量是未在当前进程中定义,而从父进程中继承而来
      的变量.export命令用来设置环境变量.至此之后,从当前
      shell脚本执行的任何程序都会继承这个变量.
      #+begin_src bash
	echo $PATH
      #+end_src

      #+RESULTS:
      : /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dream/bin

      如果需要再PATH中添加一条新的路径,可以使用:
      #+begin_src bash
	export PATH="$PATH:/home/user/bin"
      #+end_src
      这样,我们就将/home/user/bini添加到了PATH中.

**** 1.3.3补充内容
   1. 获得字符串长度:
      length=${#var}

      #+begin_src bash
	var=12345678901234567890
	echo ${#var}
      #+end_src

      #+RESULTS:
      : 20

   2. 识别当前的shell版本
      可以用下面的方法获知当前使用的是那种shell:
      #+begin_src bash
	echo $SHELL
	# 也可以用
	# 不知道为何两个命令结果不一样,本地用的是zsh
	#运行用的是bash
	echo $0
      #+end_src

      #+RESULTS:
      | /bin/zsh |
      | bash     |

   3. 检查是否为超级用户
     UID是一个重要的环境变量,可以用于检查当前脚本是以超级
     用户还是以普通用户的身份运行的.例如:
     #+begin_src bash
       if [ $UID -ne 0 ]; then
       echo Non root user.Please run as root.
       else
       echo "Root user"
       fi
     #+end_src 

     #+RESULTS:
