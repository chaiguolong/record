** 第二章 命令之乐
*** 2.1简介
    在这些使我生活变得更舒适,工作更给力的命令中,我最钟爱的是
  grep,awk,sed和find.
*** 2.2用cat进行拼接
    cat通常用于读取,显示或拼接文件内容,不过cat所具备的能力远
  不止这些.
**** 2.2.1 预备知识
    用一个单行命令组合标准输入的数据和文件数据,这可是个让人挠
  头的难题.通常的解决办法是将stdin重定向到一个文件,然后再将两
  个文件拼接到一起.但是我们可以使用cat命令一次性完成任务.
**** 2.2.2 实战演练
    cat命令是一个日常经常会使用的简单命令.cat本身表示
  concatenate(拼接).
    用cat读取文件内容的一般写法是:
    #+begin_src bash
      cat file1 file2 file3 ...
    #+end_src

    这个命令将作为命令行参数的文件内容拼接在一起作为输出.
  例如:
  #+begin_src bash
    cat file.txt
  #+end_src

**** 2.2.3 工作原理
    cat命令不仅可以读取文件并拼接数据,它还能够从标准输入中
  进行读取.
    要从标准输入中读取,就要使用管道操作符:
    #+begin_src bash
      OUTPUT_FROM_SOME COMMANDS | cat
    #+end_src
    类似的,我们可以用cat将输入文件的内容与标准输入拼接在一起.
  方法如下:
  #+begin_src bash
    # 代码中的-被作为来自stdin文本的文件名
    echo "Text through stdin" | cat - file.txt
  #+end_src

  #+RESULTS:
  | Text | through | stdin |        |        |          |          |
  | This | is      | a     | line   | inside | file.txt |          |
  | This | is      | the   | second | line   | inside   | file.txt |

**** 2.2.4 补充内容
    cat命令的另外还有一些选项可用于查看文件.
    1. 压缩空白行
       #+begin_src bash
	 # 出于可读性或者别的一些原因,有时文本中的多个空行需要
	 # 被压缩成单个.
	 # cat -s file
	 cat -s multi_blanks.txt

	 # 我们也可以用tr移除空白行
	 # 在tr的这种用法中,它将连续多个'\n'字符压缩成单个
	 # '\n'(换行符)
	 cat multi_blanks.txt | tr -s '\n'
       #+end_src

    2. 将制表符显示未^|
       #+begin_src bash
	 cat -T file.py
       #+end_src

    3. 行号
       使用cat命令的-n选项会在输出的每一行内容之间加上行号.
       #+begin_src bash
	 cat -n file.py
       #+end_src


*** 2.3录制与回放终端会话
**** 2.3.1.预备知识
    通过script和scriptreplay命令来录制终端会话.
**** 2.3.2.实战演练
    开始录制终端会话:
    #+begin_src bash
      script -t 2>timing.log -a output.session
      type commands;
      ...
      ..
      exit
    #+end_src

    我们可以按照下面的方法回放命令执行过程:
    #+begin_src bash
      # 按播放命令序列输出
      scriptreplay timing.log output.session
    #+end_src

**** 2.3.3.工作原理

    script命令同样可以用于建立可在多个用户之间进行广播的视频会话.
    打开两个终端,Terminal1和Terminal2
    1. 在Terminal1中输入一下命令:
       #+begin_src bash
	 mkfifo scriptfifo
       #+end_src
    2. 在Terminal2中输入一下命令:
       #+begin_src bash
	 cat scriptfifo
       #+end_src
    3. 返回Terminal1,输入一下命令:
       #+begin_src bash
	 script -f scriptfifo
	 commands
	 #如果要结束会话,输入exit并按回车键
       #+end_src
*** 2.4文件查找与文件列表
    find是UNIX/Linux命令行工具箱中最棒的工具之一.
**** 2.4.1.预备知识
    find命令的工作方式如下:沿着文件层次结构向下遍历,
  匹配符合条件的文件,并执行相应的操作.
**** 2.4.2.实战演练
    列出当前目录及子目录下所有的文件和文件夹
    #+begin_src bash
      # 列出当前目录及子目录下所有的文件和文件夹
      # find base_path
      find .
    #+end_src

**** 2.4.3.补充内容
    find命令的一些其它选项.
    1. 根据文件名或正则表达式匹配搜索
       选项-name的参数制定了文件名所必须匹配的字符串.
       我们可以将通配符作为参数使用.
       *.txt能够匹配所有以.txt结尾的文件名.
       选项-print在终端中打印出符合条件的文件名或文件路径.
       #+begin_src bash
	 find /home/dream/record/emacs/ -name "*.txt" -print
       #+end_src
       find命令有一个选项-iname(忽略字母大小写)
       #+begin_src bash
	 find . -iname "example.txt" -print
       #+end_src

       如果想匹配多个条件中的一个,可以采用or条件操作:
       #+begin_src bash
	 # 注意前后括号的后前空格,没有空格会报错.
	 find . \( -name "*.txt" -o -name "*.sh" \) -print
       #+end_src


       选项-path的参数可以使用通配符来匹配文件路径或文件.
       -name总是用给定的文件名进行匹配.
       -path则将文件路径作为一个整体进行匹配.
       #+begin_src bash
	 find /home/dream/record/ -path "*emacs" -print
       #+end_src

       选项-regex的参数和-path类似,只是-regex是基于正则
     表达式来匹配文件路径的.
     #+begin_src bash
       # 类似的还有-iregex
       find . -regex ".*\(\.py\|\.sh\)"
     #+end_src

    2. 否定参数
       find也可以用"!"否定参数的含义
       #+begin_src bash
	 find . ! -name "*.txt" -print
       #+end_src

    3. 基于目录深度的搜索
       find命令在使用时会遍历所有子目录.我们可以采用一些深度
       参数来限制find命令遍历的深度.-maxdepth和-mindepth就是
       这类参数.
       我们只需要再当前目录中进行查找,深度可以设置为1;
       当需要向下两级时,深度可以设置为2;
       #+begin_src bash
	 # 将最大深度限制为1
	 # 该目录只列出当前目录下的所有普通文件.
	 find . -maxdepth 1 -type f -print
       #+end_src

       打印出深度距离当前目录至少两个子目录的所有文件
       #+begin_src bash
	 find /home/dream/exercise/ -mindepth 2 -type f -print
	 # find . -mindepth 2 -type f -print
	 # find . mindepth 2 -type f -print
       #+end_src

    4. 根据文件类型搜索
       -type可以对文件搜索进行过滤,借助这个选项,我们可以为find
       命令指明特定的文件匹配类型.
       只列出所有的目录
       #+begin_src bash
	 find . -type d -print
       #+end_src

       #+RESULTS:
       | .      |
       | ./test |

       只列出普通文件
       #+begin_src bash
	 find . -type f -print
       #+end_src

       只列出符号链接
       #+begin_src bash
	 find . -type l -print
       #+end_src

       #+RESULTS:
       : ./passwd

       type参数来匹配所需要的文件类型
       #+caption: 文件类型所对应的类型参数
	|----------+----------|
	| 文件类型 | 类型参数 |
	|----------+----------|
	| 普通文件 | f        |
	|----------+----------|
	| 符号链接 | l        |
	|----------+----------|
	| 目录     | d        |
	|----------+----------|
	| 字符设备 | c        |
	|----------+----------|
	| 块设备   | b        |
	|----------+----------|
	| 套接字   | s        |
	|----------+----------|
	| Fifo     | p        |
	|----------+----------|

    5. 根据文件时间进行搜索
       UNIX/Linux文件系统中的每个文件都有三种时间戳,如下所示:
       - 访问时间(-atime):用户最近一次访问文件的时间

       - 修改时间(-mtime):文件内容最后一次被修改的时间

       - 变化时间(-ctime):文件元数据(metadata,例如权限或所有权)
	 最后一次改变的时间.

       -atime,-mtime,-ctime可以作为find的时间参数.它们可以整数值
       给出,单位是天.这些整数值通常还带有-或+:-表示小于,+表示大于.
	 - 打印出在最近七天内被访问过的所有文件
	     #+begin_src bash
	     find . -type f -atime -7 -print
	     #+end_src

	 - 打印出恰好在七天前被访问过的所有文件
	     #+begin_src bash
	     find . -type f -atime 7 -print
	     #+end_src

	 - 打印出访问时间超过七天的所有文件
	    #+begin_src bash
	    find . -type f -atime +7 -print
	    #+end_src

	 find另一个漂亮的特性是-newer参数.使用-newer,我们可以指定一个
	 用于比较时间戳的参考文件,然后找出比参考文件更新的(更长的修改
	 时间)所有文件.
	 #+begin_src bash
	   find . -type f -newer sleep.sh -print
	 #+end_src

	 find命令的时间戳操作处理选项对编写系统备份和维护脚本很有帮助.

    6. 基于文件大小的搜索
       #+begin_src bash
	 # 大于2kb的文件
	 find . -type f -size +2k
       #+end_src

       #+begin_src bash
	 # 小于2kb的文件
	 find . -type f -size -2k
       #+end_src

       #+begin_src bash
	 # 等于2kb的文件
	 find . -type f -size 2k
       #+end_src

       除了k之外,还可以用其他文件大小单元.
       - b----块(512字节)

       - c----字节

       - w----字(2个字节)

       - k----千字节

       - M----兆字节

       - G----吉字节

    7. 删除匹配的文件
       -delete可以用来删除find查找到的匹配文件
       #+begin_src bash
	 find . -type f -name "*.swp" -delete
       #+end_src


    8. 基于文件权限和所有权的匹配
       文件匹配可以根据文件权限进行
       #+begin_src bash
	 find . -type f -perm 775 -print
       #+end_src

       可以根据文件的所有权进行搜索.
       用选项-user USER(参数USER既可以是用户名也可以是UID)
       就能够找出由某个特定用户所拥有的文件
       #+begin_src bash
	 find . -type f -user dream -print
       #+end_src

    9. 结合find执行命令或动作
       find命令可以借助选项-exec与其他命名进行结合.
       #+begin_src bash
	 find . -type f -user root -exec chown dream {} \; 
       #+end_src

       #+begin_src bash
	 # -exec之后可以接任何命令.{}表示一个匹配.对于任何一个匹配
	 # 文件名,{}会被该文件名替换.
	 find . -type f -name "*.sh" -exec cat {} \; > all_sh_files.txt
       #+end_src

       #+begin_src bash
	 # 将3天前的.txt文件复制到OLD目录中:
	 find . -mtime +3 -type f -name "*.txt" -exec cp {} ./OLD/ \;
       #+end_src

       -exec结合多个命令
       我们无法再-exec参数中直接使用多个命令.它只能够接受单个命令,不过
       我们可以耍个小花招.把多个命令写到一个shell脚本中(例如:command.sh)
       然后在-exec中使用这个脚本:
       #+begin_src bash
	 -exec ./commands.sh {} \;
       #+end_src

       -exec能够同print结合来生成有用的输出信息.例如:
       #+begin_src bash
	 find -type f -name "*.txt" -exec \
	 printf "Text file:%s\n" {} \;
       #+end_src


    10. 让find跳过特定的目录
	跳过.git目录
    #+begin_src bash
      find /home/dream/shell/ \( -name ".git" -prune \) \
      -o \( -type f -print \)
    #+end_src

*** 2.5玩转xargs
      xargs是一个很有用的命令,它擅长将标准输入数据转换成
    命令行参数.
**** 2.5.1预备知识
      xargs命令应该紧跟在管道操作符之后.它以标准输入作为
    主要的源数据流,并使用stdin并通过提供命令行参数来执行
    其他命令.例如:
    #+begin_src bash
      command | xargs
    #+end_src
**** 2.5.2实战演练
      xargs命令把从stdin接收到的数据重新格式化,再将其作为
    参数提供给其他命令(默认是/bin/echo).
      - 将多行输入转换成单行输出
	#+begin_src bash
	    cat example.txt | xargs
	#+end_src
      - 将单行输入转换成多行输出
	#+begin_src bash
	    cat example.txt | xargs -n 3
	#+end_src

**** 2.5.3工作原理
      用-d选项为输入指定一个定制的定界符:
      #+begin_src bash
	echo "splitXsplitXsplitXsplit" | xargs -d X
      #+end_src

      同时结合-n,我们可以将输入划分成多行,而每行包含
      两个参数
      #+begin_src bash
	echo "splitXsplitXsplitXsplit" | xargs -d X -n 2
      #+end_src

**** 2.5.4补充内容
    1. 读取stdin,将格式化参数传递给命令
       小型定制化echo(见cecho.sh)
       #+begin_src bash
	 cat args.txt | xargs ./cecho.sh
       #+end_src

       xargs有一个选项-I,可以用-I指定一个替换字符串,
       这个字符串在xargs扩展时会被替换掉.当-I与xargs
       结合使用时,对于每一个参数,命令都会被执行一次.

       #+begin_src bash
	 cat args.txt | xargs -I {} ./cecho.sh -p {} -l
       #+end_src

    2. 结合find使用xargs
       只要我们把find的输出作为xargs的输入,就必须将-print()与
       find结合使用,以字符null来分隔输出(如果分隔符是'',则可
       能回误删其它文件或者不是预期的答案)
       #+begin_src bash
	 # xargs -0将\0作为输入定界符
	 find . -type f -name "*.txt" -print0 | xargs -0 rm -f
       #+end_src
    3. 统计源代码目录中所有sh程序文件的行数
       #+begin_src bash
	 find . -type f -name "*.sh" -print0 | xargs -0 wc -l
       #+end_src

    4. 结合stdin,巧妙运用while语句和子shell
       #+begin_src bash
	 cat files.txt | (while read arg; do cat $arg; done)
       #+end_src
       
*** 2.6用tr进行转换

      tr可以对来自标准输入的字符进行替换,删除
    以及压缩.它可以将一组字符变成另一组字符,因
    而通常也被称为转换(translate)命令.
**** 2.6.1 预备知识
      tr只能通过stdin,而无法通过命令行参数来接收输入.
    它的调用格式如下:
    #+begin_src bash
      tr [option] set1 set2
    #+end_src
**** 2.6.2 实战演练
      将输入字符由大写转换成小写,可以使用下面的
    命令:
    #+begin_src bash
      echo "HELLO WHO IS THIS" | tr 'A-Z' 'a-z'
    #+end_src

**** 2.6.3 工作原理
      用tr进行数字加密和解密
      #+begin_src bash
	echo 12345 | tr '0-9' '9876543210'
	echo 87654 | tr '0-9' '9876543210'
      #+end_src

      用tr进行ROT13加密:
      #+begin_src bash
	echo "tr came, tr saw, tr conquered." | tr \
	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' \
	'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'

	echo "ge pnzr ge fnj ge pbadhrerq." | tr \
	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' \
	'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'
      #+end_src

      tr将制表符转换成空格:
      #+begin_src bash
	cat text | tr '\t' ''
      #+end_src

**** 2.6.4 补充内容
       1. 用tr删除字符
	  tr有一个选项-d,可以通过制定需要被删除的字符集合,将
	  出现在stdin中的特定字符清除掉:
	#+begin_src bash
	  # 只使用set1,不使用set2
	  cat file.txt | tr -d '[set1]'
	#+end_src

       #+begin_src bash
	 # 将stdin中的数字删除并打印出来
	 echo "Hello 123 world 456" | tr -d '0-9'
       #+end_src

       2. 字符集补集
	  我们可以利用选项-c来使用set1的补集.
       #+begin_src bash
	 # set1的补集意味着这个集合中包含set1中没有的所有字符.
	 tr -c [set1] [set2]
       #+end_src

         从输入文本中将不在补集中的所有字符全部删除.
	 #+begin_src bash
	   echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'
	 #+end_src

       3. 用tr压缩
	  多数情况下,连续的重复字符应该被压缩成单个字符,而
	  经常需要进行的一想任务就是压缩空白字符.

	  tr的-s选项可以压缩输入中重复的字符,方法如下:
       #+begin_src bash
	 echo "GNU is not UNIX.        Recursive right ?" | tr -s ' '
	 echo "GNU is not UNIX.        Recursive right ?"
       #+end_src

       让我们用一种巧妙的方式用tr将文件中的数字列表进行相加:
       #+begin_src bash
	 # 不知如何,下面代码错误
	 #cat sum.txt | echo $[ ( tr '\n' '+' ) 0 ]
	 cat sum.txt | echo  [  ( tr '\n' '+' ) 0 ]
       #+end_src

       1. 字符类
	  tr可以像使用集合一样使用各种不同的字符类,这些字符
	  类如下所示:
	  - almnu: 字母和数字
	  - alpha: 字母
	  - cntrl: 控制(非打印)字符
	  - digit: 数字
	  - graph: 图形符号
	  - lower: 小写字母
	  - print: 可打印字符
	  - punct: 标点符号
	  - space: 空白字符
	  - upper: 大写字母
	  - xdigit: 十六进制字符

	  可以按照下面的方式选择并使用所需的字符类:
	  tr [:class:] [:class:]
	  例如:
	  tr '[:lower:]' '[:upper:]'
*** 2.7校验和核实

*** 2.8排序,单一与重复

*** 2.9临时文件命名与随机数

*** 2.10分割文件和数据

*** 2.11根据扩展名且分文件名

*** 2.12批量重命名和移动

*** 2.13拼写检查与词典操作

*** 2.14交互输入自动化
