** 以文件之名
*** 3.1 简介
    UNIX操作系统中的一切都视为文件.
*** 3.2 生成任意大小的文件
    由于各种可能的原因,你也许需要生成一个包含随机数据的文件.
**** 3.2.1 实战演练
    创建特定大小的大文件最简单的方法就是利用dd命令.
    #+begin_src bash
      dd if=/dev/zero of=junk.data bs=1M count=1
    #+end_src
    if代表输入文件(input file),of代表输出文件(output file),bs
代表以字节为单位的块大小(block size),count代表需要被复制的块数.
    /dev/zero是一个字符设备,它会不断返回0值字节(\0).
*** 3.3 文本文件的交集与差集
    交集和差集操作在集合论相关的数学课上经常被用到.不过,对文本
进行类似的操作在某些情况下也很有用.
**** 3.3.1 预备知识
    comm命令可用于两个文件之间的比较.
    假设现在有两个文件A和B,内容分别是:A(1,2,3),B(3,4,5).
那么,对这两个文件进行操作的结果如下.
交集: 3
求差: 1,2,4,5
差集(A): 1,2
- 交集: 打印出两个文件所共有的行
- 求差: 打印出指定文件所包含的且不相同的那些行
- 差集: 打印出包含在文件A中,但不包含在其他指定文件中的那些行
**** 3.3.2 实战演练
    需要注意的是comm必须使用排过序的文件作为输入.请看下面的例子:
    #+begin_src bash
      # 将A.txt排序并输出给A.txt
      sort A.txt -o A.txt
      # 将B.txt排序并输出给B.txt
      sort B.txt -o B.txt
      #将A.txt与B.txt做比较
      com A.txt B.txt
    #+end_src
    有一些选项可以按照我们的需求进行格式化输出,例如:
    - -1 从输出中删除第一列
    - -2 从输出中删除第二列
    - -3 从输出中删除第三列
    为了打印两个文件的交集,我们需要删除第一列和第二列,只打印出
第三列:
    #+begin_src bash
      comm A.txt B.txt -1 -2
    #+end_src

    打印出两个文件中不相同的行:
    #+begin_src bash
      comm A.txt B.txt -3
    #+end_src

    #+begin_src bash
      # 删除\t字符
      comm A.txt B.txt -3 | sed 's/^\t//'
    #+end_src

    差集操作允许你比较两个文件,并打印出只在A.txt或B.txt中出现
的行.当A.txt和B.txt作为comm命令的参数时,输出中的第一列是A.txt
相对于B.txt的差集,第二列是B.txt相对于A.txt的差集.
    #+begin_src bash
      # A.txt的差集
      comm A.txt B.txt -2 -3
    #+end_src

    #+begin_src bash
      comm A.txt B.txt -1 -3
    #+end_src

*** 3.4 查找并删除重复文件
    这则攻略中,我们讨论的是查找重复文件并基于查找结果执行相关的
操作.
**** 3.4.1 预备知识
    重复文件指的是那些虽然名字不同但内容却一模一样的文件.我们可
以通过比较文件内容来识别它们.校验和是依据文件内容来计算的,内容
相同的文件自然会生成相同的校验和,因此,我们可以通过比较校验和来
删除重复文件.
**** 3.4.2 实战演练
    按照下面的方法创建一些测试文件:
    #+begin_src bash
      echo "hello" > test1;
      cp test1 test_copy1;
      cp test1 test_copy2;
      echo "next" > other;
    #+end_src

**** 3.4.3 工作原理
**** 3.4.4 参考
*** 3.5 创建长路径目录
    有时候,我们需要创建一个空目录树.如果给定路径中包含目录,那么
还必须检查这些目录是否已经存在.这会使得代码变得臃肿而低效.
**** 3.5.1 预备知识
    mkdir命令用于创建目录.
    #+begin_src bash
      mkdir dirpath
    #+end_src
    如果目录已经存在,就会返回"File exists"错误信息:

    如果给你一个目录路径(/home/slynux/test/hello/child),其中
/home/slynux已经存在,那么我们需要创建路径中余下的目录
(/home/slynux/test,/home/slynux/test/hello和/home/slynux/test
/hello/child).
    下面的代码可找出路径中的每个目录是否存在:
    #+begin_src bash
      if [ -e /home/slynux ]; then
      # 创建下一级目录
    #+end_src
    -e是一个用在条件判断[ ]中的参数,可用以判断某个文件是否存在.
    在类unix系统中,目录同样是一种文件.如果[ -e FILE_PATH ] 返回
    真.
**** 3.5.2 实战演练
   下面的命令序列可用以创建多级目录树:
   #+begin_src bash
     mkdir /home 2> /dev/null
     mkdir /home/slynux 2> /dev/null
     mkdir /home/slynux/test 2> /dev/null
     mkdir /home/slynux/test hello 2> /dev/null
     mkdir /home/slynux/test/hello/child 2> /dev/null
   #+end_src
   如果遇到"Dictionary exists"这种错误,该命令会被忽略,错误信息
   通过2>被重定向到/dev/null.进行这一操作的标准单行命令如下:
   #+begin_src bash
     # 它会忽略所有已存在的目录,同时创建缺失的部分.
     mkdir -p /home/slynux/test/hello/child
   #+end_src
*** 3.6 文件权限,所有权和粘滯位
    文件权限和所有权是unix/Linux文件系统最显著的特性之一.
**** 3.6.1 预备知识
    文件权限的第一个字母对应关系如下所示.
    - "-"--------普通文件
    - "d"--------目录
    - "c"--------字符设备
    - "b"--------块设备
    - "l"--------符号链接
    - "s"--------套接字
    - "p"--------管道

    目录有一个特殊的权限,叫做粘滞位.当一个目录设置了粘滞位,
    只有创建该目录的用户才能删除目录中的文件,即使用户组和其
    他用户也有写权限.粘滞位出现在其他用户权限中的执行权限(x)
    位置.它使用t或T来表示.如果没有设置执行权限,但设置了粘滞位,
    那么使用t;如果同时设置了执行权限和粘滞位,就使用T.例如
    -------rwt, -------rwT
**** 3.6.2 实战演练
    为了设置文件权限,可以使用chmod命令.
    #+begin_src bash
      chmod u=rwx g=rw o=r filename
    #+end_src
    - u = 指定用户权限
    - g = 指定用户组权限
    - o = 指定其他实体权限

    如果需要给文件添加权限,可以对用户,用户组和其他用户用+进行
    添加,用-删除权限.
    一个文件已经具有权限rwx rw- r--,现在需要增加可执行权限:
    #+begin_src bash
      chmod a+x filename
    #+end_src
    给所有权限类别(即用户,用户组和其他用户)增加可执行权限:
    #+begin_src bash
      # 其中a表示全部(all)
      chmod a+x filename
      # 如果需要删除权限,则使用-,例如:
      chmod a-x filename
    #+end_src

    也可以用八进制数来设置权限.权限由3位八进制数来表示.每一位
    按顺序对应用户,用户组和其他用户.
    - r--  = 4
    - -w-  = 2
    - --x  = 1

    我们可以将权限序列的八进制值相加来获得所需的权限组合,例如:
    - rw- = 4 + 2 = 6
    - r-x = 4 + 1 = 5

    权限序列 rwx rw- r--的数字表示形式如下:
    - rwx = 4 + 2 + 1 = 7
    - rw- = 4 + 2 = 6
    - r-- = 4

    因此,rwx rw- r-- 等于764,那么使用8进制值设置权限的命令为:
    #+begin_src bash
      chmod 764 filename
    #+end_src
**** 3.6.3 补充内容
   1. 更改所有权
      #+begin_src bash
	# 要更改文件所有权,可以使用chown命令:
	# chown user.group filename
	# 在这里,slynux即使用户名,也是用户组名.
	chown slynux.slynux test.sh
      #+end_src
   
   2. 设置粘滞位
      粘滞位是一种应用于目录的权限类型.通过设置粘滞位,使得只有
      目录的所有者才能够删除目录中的文件.

   3. 以递归的方式设置权限
      有时候,要以递归的方式修改当前目录下的所有文件和子目录的
      权限,可以使用下面的方法:
      #+begin_src bash
	# 选线-R指定以递归的方式修改权限.
	chmod 777 . -R
	# 我们用"."指定当前工作目录,这等同于:
	chmod 777 $(pwd) -R
      #+end_src

   4. 以递归方式设置所有权
      用chown命令结合 -R就可以以递归的方式设置所有权:
      #+begin_src bash
	chown user.group . -R
      #+end_src

   5. 以不同的用户运行可执行文件
      一些可执行文件需要以不同的用户身份(启动该文件的当前用户
      之外的用户),用文件路径来执行(如 ./executable_name).有一
      个叫做setuid的特殊文件权限,它允许其他用户以文件所有者的
      身份来执行文件.

      首先将该文件的所有权替换为该用户,这操作每次都会执行,使
      该用户能以文件所有者的身份登录.然后运行下面的命令:
      #+begin_src bash
	chmod +s executable_file
      #+end_src
      
      #+begin_src bash
	# chown root.root executable_file
	# chmod +s executable_file
	./eecutable_file
      #+end_src
      现在,这个文件实际上每次都是以超级用户的身份来执行.
      setuid的使用不是无限制的.为了安全,它只能应用在Linux ELF
      格式二进制文件上,而不能用于脚本文件.

*** 3.7 创建不可修改文件
**** 3.7.1 预备知识
**** 3.7.2 实战演练
*** 3.8 批量生成空白文件
**** 3.8.1 预备知识
**** 3.8.2 实战演练
*** 3.9 查找符号链接及其指向目标
**** 3.9.1 预备知识
**** 3.9.2 实战演练
*** 3.10 列举文件类型统计信息
**** 3.10.1 预备知识
**** 3.10.2 实战演练
**** 3.10.3 工作原理
*** 3.11 换回文件与挂载
**** 3.11.1 预备知识
**** 3.11.2 实战演练
**** 3.11.3 补充内容
*** 3.12 生成ISO文件及混合iso
**** 3.12.1 预备知识
**** 3.12.2 实战演练
**** 3.12.3 补充内容
*** 3.13 查找文件差异并进行修补
**** 3.13.1 实战演练
**** 3.13.2 补充内容
*** 3.14 head与tail--打印文件的前10行和后10行
*** 3.15 只列出目录的其他方法
**** 3.15.1 预备知识
**** 3.15.2 实战演练
*** 3.16 在命令行中用pushd和popd快速定位
*** 3.17 统计文件的行数,单词数和字符数
*** 3.18 打印目录树
