.内存储存单元按组划分成很多块,这些块称为页面(page).内核将每个内存页面放在屋里内存或交换空间.然后,内核会维护一个内存页面表,指明哪些页面位于物理内存内,哪些页面被换到了磁盘上.
2.linux操作系统有5个启动运行级:
	1>: 运行级为1时,只启动基本的系统进程以及一个控制台终端进程,
		我们称之为单用户模式.单用户模式通常用来在系统有问题时进
		行紧急的文件系统维护.显然,在这种模式下,仅有一个人(通常是
		系统管理员)能登录到系统上操作数据.
	2>: 标准的启动运行级是3.在这个运行级上,大多数的应用软件,比如
		网络支持程序,都会启动.
	3>: 另一个linux中常见的运行级是5.在这个运行级上系统会启动图
		形化的X Window系统,允许用户通过图形化桌面窗口登录系统.

3.linux系统将硬件设备当成特殊的文件,称为设备文件.设备文件有3中分类:
	1>: 字符型设备文件
		字符型设备文件是指处理数据时每次只能处理一个字符的设备.大多
		数类型的调制解调器和终端都是作为字符型设备文件创建的.
	2>: 块设备文件
		块设备文件是指处理处理数据时每次能处理大块数据的设备,比如硬
		盘.
	3>: 网络设备文件
		网络设备文件是指采用数据包发送和接收数据的设备,包括各种网卡
		和一个特殊的回环设备.这个回环设备允许linux系统使用常见的网
		络编程协议同自身通信.

4.过滤输出列表
	ls -l my_script
	#问号(?)代表一个字符;
	#星号(*)代表零个或多个字符.
	#中括号([])代表一个字符位置并给出多个可能的选择.
	#感叹号(!)代表将不需要的内容排除在外.
	ls -l my_scr?pt
	ls -l my_s*t
	ls -l f[a-i]ll
	ls -l f[!a]ll
	#上面的叫做文件扩展匹配,指的是实用通配符进行模式匹配的过程.通配符正式的名称叫做元字符通配符.

5.touch命令可以用来改变文件的修改时间.
6.ls -d *Scripts        #-d选项只列出目录本身的信息,不列出其中的内容.
  ls -li *Scripts       #-i选项显示出inode.
7.软连接:是两个完全不同的文件.硬链接:它们从根本上而言是同一个文件.
8.file my_file          #file命令是能够探测文件的内部,并决定文件是什么类型的.
9.用more命令代替cat命令,因为more命令有分页.
10.less命令是more命令的升级版(less is more).
11.tail -n 2 log_file   #显示文件的最后2行.(head命令同理)
12.Linux进程信号:
  +--------------------------------------------------------------------+
  | 信号                名称               描述                        |
  | 1                   HUP                挂起                        |
  | 2                   INT                中断                        |
  | 3                   QUIT               结束运行                    |
  | 9                   KILL               无条件终止                  |
  | 11                  SEGV               段错误                      |
  | 15                  TERM               尽可能终止                  |
  | 17                  STOP               无条件停止运行,但不终止     |
  | 18                  TSTP               停止或暂停,但在后台继续运行 |
  | 19                  CONT               在STOP或TSTP之后恢复执行    |
  +--------------------------------------------------------------------+

    kill命令:
    默认情况下,kill命令会向命令行中列出的全部PID发送一个TERM信号.
    要发送进程信号,你必须是进程的属主或登录为root用户.
    如果要强制终止,-s参数支持指定其他信号(用信号名或信号值)
    $ kill 3940             #默认的是TERM信号.
    $ kill -s HUP 3940

13.mount命令:
    mount -t type device directory      

    mount -t vfat /dev/sdb1 /media/disk
    #type(文件系统类型) 
    #device(该存储设备的设备文件的位置) 
    #directory(挂载点在虚拟目录中的位置)

14.umount命令(命令名中没有n):
    umount [directory | device] 

15.du命令:该命令可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况.
    -c:显示所有已列出文件总的大小
    -h:按用户易读的格式输出大小,即用K代替千字节等
    -s:显示每个输出参数的总计

16.sort命令:
    sort -n file2   #-n参数,它会告诉sort命令把数字识别成数字而不是字符,并按值排序.
    sort -M file3   #-M参数,按照月排序.
    Jan
    Feb
    Mar
    ...
    Oct
    Nov
    Dec
    
    sort -t ':' -k 3 -n /etc/passwd
    #-t参数来指定字段分隔符,-k参数来指定排序的字段,-n参数按照数值排序.
    
    $ du -sh * | sourt -nr          #-r参数将结果按降序输出.

17.grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。
    grep [option] pattern [file]

    #-v(输出不匹配该模式的行)
    +-------------------+
    | $ grep -v t file1 |  
    | one               |
    | four              |
    | five              |
    | $                 |
    +-------------------+
    #-n(显示匹配模式的行所在的行号)
    +-------------------+
    | $ grep -n t file1 |
    | 2:two             |
    | 3:three           |
    | $                 |
    +-------------------+
    #-c(只要知道有多少行含有匹配的模式)
    +-------------------+
    | $ grep -c t file1 |
    | 2                 |
    | $                 |
    +-------------------+
    #-e(如果要指定多个匹配模式)
    +---------------------+
    |$ grep -e t -e f file|
    |two                  |
    |three                |
    |four                 |
    |five                 |
    |$                    |
    +---------------------+
    
    默认情况下,grep命令用基本的Unix风格正则表达式来匹配模式.
    Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式.
    简单例子:正则表达式中的方括号表明搜索包含t或者f字符的匹配,
    如果不用正则表达式,grep就会搜索匹配字符串tf的文本.
   +--------------------+
   |$ grep [tf] file1   |
   |two                 |
   |three               |
   |four                |
   |five                |
   +--------------------+

18.进程列表:你可以在一行中指定要依次运行的一系列命令.
            这可以通过命令列表来实现,只需要在命令之间
            加入(;)即可
    $ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls

    在上面的例子中,所有的命令依次执行,不存在任何问题.
    不过这并不是进程列表.命令列表想要成为进程列表,
    这些命令必须包含在括号里.

    $ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls )

    尽管多出来的括号看起来没有什么太大的不同,但气到的效果
    确是非同寻常.括号的加入使命令列表变成了进程列表,生成
    了一个子shell来执行对应的命令.
    ####################################################
    进程列表是一种命令分组.另一种命令分组是将命令放入花括
    号中,并在命令列表尾部加上分号(;),语法为{command};使用
    花括号进行命令分组并不会像进程列表那样创建子shell.
    ####################################################

    想要知道是否生成了子shell,借助环境变量命令:
    echo $BASH_SUBSHELL     #该命令放回0,就表示没有子shell,
    如果返回1或者其他更大的数字,就表明存在子shell.

19.要想将命令置入后台模式,可以在命令末尾加上字符&.
20.jobs命令来显示后台作业信息.
21.在CLI中运用子shell的创造性方法之一就是讲进程列表置入后
   台模式.你既可以在子shell中进行繁重的处理工作,同时也不会
   让子shell的I/O受制于终端.
   下面创建备份文件的命令就是有效利用后台进程列表的一个更实用的例子.
   (tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&

22. 协程:协程可以同时做两件事.它在后台生成一个子shell,
    并在这个子shell中执行的命令.
   +-----------------------------------------------------+
   |$ coproc sleep 10                                    |
   |[1] 2544                                             |
   |$                                                    |
   |                                                     |
   |$ jobs                                               |
   |[1]+ Running                coproc COPROC sleep 10 & |
   |$                                                    |
   +-----------------------------------------------------+

	将协程于进程列表结合起来产生嵌套的子shell.只需要输入进程
	列表,然后把命令coproc放在前面就可以了.
  +------------------------------------------------------+
  | $ coproc ( sleep 10; sleep 2 )						 |
  | [1] 2574											 |
  | $													 |
  | $ jobs												 |
  | [1]+ Running coproc COPROC ( sleep 10; sleep 2 ) &	 |
  | $													 |
  | $ ps --forest										 |
  |   PID TTY          TIME CMD							 |
  |  2483 pts/12   00:00:00 bash						 |
  |  2574 pts/12   00:00:00  \_ bash					 |
  |  2575 pts/12   00:00:00  |   \_ sleep				 |
  +------------------------------------------------------+

23. shell命令分为内建命令和非内建命令(外部命令),外部命令,有时候也被称
	为文件系统命令,是存在于bash shell之外的程序.当外部命令执行时,会创
	建出一个子进程.这种操作被称为衍生(forking).ps就是一个外部命令.
    bash(pid=2743)创建了一个子进程(pid=2801,ppid=2743) 
  +-------------------------------------------------------+
  | $ ps -f                                               |
  | UID      PID  PPID C STIME TTY      TIME        CMD   |
  | christi+ 2743 2742 0 17:09 pts/9    00:00:00    -bash |
  | christi+ 2801 2743 0 17:16 pts/9    00:00:00    ps -f |
  | $                                                     |
  +-------------------------------------------------------+
	
	
24. 环境变量:
    1).全局环境变量对于shell会话和所有生成的子shell都是可见的.局部变
    量则只对床架它们的shell可见.
    2).查看全局变量,可以使用env或者printenv命令
    3).要显示个别环境变量的值,可以使用printenv命令,但是不要用env命令
   +-------------------------------------+
   |$ printenv HOME /home/Christine      |
   |$                                    |
   |$ env HOME                           |
   |env: HOME: No such file or directory |
   |$                                    |
   +-------------------------------------+
    
    4).设置局部用户定义变量:通过等号给环境变量赋值.
   +-------------------------+
   |$ echo $my_variable      |
   |                         |
   |$ my_variable=Hello      |
   |$                        |
   |$ echo $my_variable Hello|
   +-------------------------+                      
	5).如果要给变量赋一个含有空格的字符串值,
	必须用单引号来界定字符串的首和尾. 
   +-------------------------------+
   |$ my_variable=Hello World      |
   |-bash: World: command not found|
   |$                              |
   |$ my_variable="Hello World"    |
   |$                              |
   |$ echo $my_variable            |
   |Hello World                    |
   +-------------------------------+
	6).***:变量名,等号和值之间没有空格.***
   +-------------------------------------+
   |$ my_variable = "Hello World"        |
   |-bash: my_variable: command not found|
   |$                                    |
   +-------------------------------------+
    7).设置了局部环境变量后,就能在shell进程的任何地方使用它了.
    但是,如果生成了另外一个shell,它在子shell中就不可用了.
   +-------------------------------+
   |$ my_variable="Hello World"    |
   |$                              |
   |$ bash                         |
   |$                              |
   |$ echo $my_variable            |
   |$ exit                         |
   |exit                           |
   |$                              |
   |$ echo $my_variable Hello World|
   |$                              |
   +-------------------------------+

    8).设置全局环境变量
    创建全局环境变量的方法是先创建一个局部环境变量,
    然后在把它导出到全局环境中.这个过程通过export命令来完成,变量名前
    不需要加$.
   +------------------------------------+
   |$ my_variable="I am Global now"     |
   |$                                   |
   |$ export my_variable                |
   |$                                   |
   |$ echo $my_variable                 |
   |I am Global now                     |
   |$                                   |
   |$ bash                              |
   |$                                   |
   |$ echo $my_variable                 |
   |I am Global now                     |
   |$                                   |
   |$ exit                              |
   |exit                                |
   |$                                   |
   |$ echo $my_variable                 |
   |I am Global now                     |
   |$                                   |
   +------------------------------------+

    9).修改子shell中全局环境变量并不会影响到父shell中该变量的值.
    子shell甚至无法使用export命令改变父shell中全局环境变量的值
   +---------------------------------+
   |$ my_variable="I am Global now"  |
   |$ export my_variable             |
   |$                                |
   |$ echo $my_variable              |
   |I am Global now                  |
   |$                                |
   |$ bash                           |
   |$                                |
   |$ echo $my_variable              |
   |I am Global now                  |
   |$                                |
   |$ my_variable="Null"             |
   |$                                |
   |$ export my_variable             |
   |$                                |
   |$ echo $my_variable              |
   |Null                             |
   |$                                |
   |$ exit                           |
   |exit                             |
   |$                                |
   |$ echo $my_variable              |
   |I am Global now                  |
   |$                                |
   +---------------------------------+

    10).删除环境变量用unset,记住不要使用$.
    何时使用$:如果要用到变量,使用$;如果操作变量,不使用$(printenv除外)
   +--------------------+
   |$ echo $my_variable |
   |I am Global now     |
   |$                   |
   |$ unset my_variable |
   |$                   |
   |$ echo $my_variable |
   |                    |
   |$                   |
   +--------------------+

    11).当用户登录是,shell会执行/etc/profile.d/目录下的脚本,因为在
    /etc/profile文件中遍历了该目录,然后执行该目录下的脚本.
  +-----------------------------------------------------------+
  | for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do |
  |     if [ -r "$i" ]; then                                  |
  |         if [ "${-#*i}" != "$-" ]; then                    |
  |             . "$i"                                        |
  |         else                                              |
  |             . "$i" >/dev/null                             |
  |         fi                                                |
  |     fi                                                    |
  +-----------------------------------------------------------+

    12).usermod命令是用户账户修改工具中最强大的一个.
        usermod -c  用户名      #修改备注字段
        usermod -L  用户名      #锁定账户,使用户无法登陆
        usermod -c  用户名      #修改备注字段
        usermod -U  用户名      #解除锁定,使用户能登录

    13).为大量用户修改密码:chpasswd命令可以事半功倍.
        chpasswd < users.txt    #user.txt含有userid:passwd对

25.理解文件权限:
    1). umask命令用来设置所创建文件和目录的默认权限.
        umask值只是掩码.它会屏蔽掉不想授予该安全级别的权限.
        对文件来说,全权限的值是666,目录是777.umask值0022.
        文件权限(666-022)就是644.目录权限(777-022)就是755.
        大多数发行版中,umask值会设置在/etc/profile启动文件.

	2).chown命令也支持同时改变文件的属主和属组.在属主和属组中用点号(.)隔开.
		# chown dan.shared newfile
		# ls -l newfile
		-rw-rw-r--    1 dan      shared             0 Sep 20 19:16 newfile
		#

26.共享文件.
	1).Linux系统上共享文件的方法是创建组.

	2).Linux还为每个文件和目录存储了3个额外的信息位。
		1>.设置用户ID(SUID):当文件被用户使用时,程序会以文件属主的权限运行.
		2>.设置组ID(SGID):对文件来说,程序会以文件属组的权限运行;对目录来说,目录中创建的新文件会以目录的默认属组作为默认属组.
		3>.粘着位:进程结束后文件还驻留(粘着)在内存中.
		SGID位对文件共享非常重要.启用SGID位后,你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组.
      +------------------------------------------------------------+
      | $ mkdir testdir                                            |
      | $ ls -l                                                    |
      | drwxrwxr-x    2 rich    rich    4096 Sep 20 23:12 testdir/ |
      | $ chgrp shared testdir                                     |
      | $ chmod g+s testdir                                        |
      | $ ls -l                                                    |
      | drwxrwsr-x    2 rich    shared  4096 Sep 20 23:12 testdir/ |
      | $ umask 002                                                |
      | $ cd testdir                                               |
      | $ touch testfile                                           |
      | $ ls -l                                                    |
      | total 0                                                    |
      | -rw-rw-r--    1 rich    shared  0 Sep 20 23:13 testfile    |
      | $                                                          |
      +------------------------------------------------------------+

27.管理文件系统.
    1).日志文件系统,Linux中有3种广泛使用的日志方法
        1>.数据模式:索引节点和文件都会被写入日志,丢失数据风险低,但性能差.
        2>.有序模式:只有索引节点数据会被写入日志,但只有数据成功写入后才会删除,在性能和安全性之间取得了良好的折中.
        3>.回写模式:只有索引节点数据会被写入日志,但不控制文件数据何时写入.丢失数据风险高,但仍比不用日志好

28.简单的shell命令.
    0).shell的给变量赋值运算,在"="不允许有空格.
	1).还有另外一种输入重定向的方法,称为内联输入重定向.
	这种方法无需使用文件进行重定向,只需要在命令行中指定用于输入重定向的数据就可以了.
	内联输入重定向符号是远小于号(<<).
	除了这个符号,你必须指定一个文本标记来划分输入数据的开始和结尾.
	任何字符串都可作为文本标记,但在数据的开始和结尾文本标记必须一致.
   +-----------------+
   |command << marker|
   |data             |
   |marker           |
   +-----------------+

    2).处理数学表达式来计算.
    使用可以用美元符和方括号($[ operation  ])将数学表达式
    +-----------------+
    | $ var1=$[1 + 5] |
    | $ echo $var1    |
    | 6               |
    +-----------------+

    3).bash内建的计算器:bc
    +----------+
    | $ bc -q  |
    | 3.44 / 5 |
    | 0        |
    | scale=4  |
    | 3.44 / 5 |
    | .6880    |
    | quit     |
    | $        |
    +----------+
    scale变量的默认值是0.在scale值被设置前，bash计算器的计算结果不包含小数位.
    在将其值设置成4后,bash计算器显示的结果包含四位小数.
    -q命令行选项可以不显示bash计算器冗 长的欢迎信息.

    4).内联输入重定向到bc内建计算器上.
    +----------------------+
    | variable=$(bc << EOF |
    | options              |
    | statements           |
    | expressions          |
    | EOF )                |
    +----------------------+

    5).Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码

29.使用结构化命令.
    1).bash shell提供了另一种条件测试方法.
      +-------------------+
      | if [ condition  ] |
      | then              |
      | commands          |
      | fi                |
      +-------------------+
    方括号定义了测试条件.
    注意第一个方括号之后和第二个方括号之前必须加上一个空格,否则就会报错
   +---------------------------------------------------+
   |Tip: if/test结构中的左中括号是调用test的命令标识,  | 
   |     右中括号是关闭条件判断的                      | 
   +---------------------------------------------------+
	2).test命令可以判断三类条件:
		1>.数值比较(test测试中不能比较浮点值)
			使用test命令最常见的情形是对两个数值进行比较
         +---------------------------------------------------+
         |  比较                            描述             |
         +---------------------------------------------------+
         |  n1 -eq n2               检查n1是否与n2相等       |
         |  n1 -ge n2               检查n1是否大于等于n2     |
         |  n1 -gt n2               检查n1是否大于n2         |
         |  n1 -le n2               检查n1是否小于等于n2     |
         |  n1 -lt n2               检查n1是否小于n2         |
         |  n1 -ne n2               检查n1是否不等于n2       |
         +---------------------------------------------------+
		2>.字符串比较
			2.1).大于号和小于号必须转义,否则shell会把它们当作重定向符号,
				把字符串值当作文件名
			2.2).大于和小于顺序和sort命令所采用的不同
			比较测试中使用的是标准的ASCII顺序,根据每个字符的ASCII数值来决定排序结果.
			sort命令使用的是系统的本地化语言设置中定义的排序顺序.
			对于英语,本地化设置指定了在排序顺序中小写字母出现在大写字母前.
			2.3).-n和-z可以检查一个变量是否含有数据(-n:判断字符串长度是否为非0;-z判断长度是否为0)
		3>.文件比较
    +-----------------------------+------------------------------------------+
    |     比较                    |         描述                             |
    +-----------------------------+------------------------------------------+
    |   -d file                   | 检查file是否存在并是一个目录             |
    |   -e file                   | 检查file是否存在                         |
    |   -f file                   | 检查file是否存在并是一个文件             |
    |   -r file                   | 检查file是否存在并可读                   |
    |   -s file                   | 检查file是否存在并非空(-s:size > 0)      |
    |   -w file                   | 检查file是否存在并可写                   |
    |   -x file                   | 检查file是否存在并可执行                 |
    |   -O file                   | 检查file是否存在并属当前用户所有         |
    |   -G file                   | 检查file是否存在并且默认组与当前用户相同 |
    |   file1 -nt file2           | 检查file1是否比file2新                   |
    |   file1 -ot file2           | 检查file1是否比file2旧                   |
    +-----------------------------+------------------------------------------+

	4>.if-then的高级特性
		bash shell提供了两项可在if-then语句中使用的高级特性:
		1).用于数学表达式的双括号
            (( expression ))      --------val++,val--,++val,--val,!,~,**等
		2).用于高级字符串处理功能的双方括号
            [[ expression ]]
        Tip:它提供了test命令未提供的另一个特性——模式匹配(pattern matching)

    5>.case命令
        可以通过竖线操作符在一行中分隔出多个模式模式
        星号会捕获所有与已 知模式不匹配的值("*"相当于java中的default)
		$ cat test26.sh 
     +---------------------------------------------------------+
     |  #!/bin/bash                                            |
     |  # using the case command #                             |
     |  case $USER in                                          |
     |  rich | barbara)                                        |
     |     echo "Welcome, $USER"                               |
     |     echo "Please enjoy your visit";;                    |
     |  testing)                                               |
     |    echo "Special testing account";;                     |
     |  jessica)                                               |
     |     echo "Do not forget to log off when you're done";;  |
     |  *)                                                     |
     |     echo "Sorry, you are not allowed here";;            |
     |  esac                                                   |
     +---------------------------------------------------------+
    
6>. 在处理代码量较大的脚本时,可能在一个地方需要修改IFS的值,
    然后忽略这次修改，在脚本的其他地方继续沿用IFS的默认值.
    一个可参考的安全实践是在改变IFS之前保存原来的IFS值,之后再恢复它.
    这种技术可以这样实现:
    IFS.OLD=$IFS 
    IFS=$'\n'   <在代码中使用新的IFS值> 
    IFS=$IFS.OLD

7>.跳出外部循环
	有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值:
	break n
	其中n指定了要跳出的循环层级。默认情况下，n为1，表明跳出的是当前的循环.如果你将n设为2，break命令就会停止下一级的外部循环.

8>.bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的 所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字:$0是程序名，$1是第 一个参数，$2是第二个参数，依次类推，直到第九个参数$9

9>.如果脚本需要的命令行参数不止9个，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上花括号，比如${10}

10>.basename命令会返回不包含路径的脚本名.
	例如:name=$(basename $0)

11>.特殊参数变量:
	1.特殊变量$#含有脚本运行时携带的命令行参数的个数
	2.特殊变量${!#}代表最后一个命令行参数变量
	3.$*和$@变量可以用来轻松访问所有的参数:
	$*变量会将所有参数当成单个参数，而$@变量会单独处理每个参数.这是遍历命 令行参数的一个绝妙方法

12>.文件描述符			缩写			描述
		0				STDIN			标准输入
		1				STDOUT			标准输出
		2				STDERR			标准错误

13>.重定向错误.
	1.只重定向错误.		2> file
	2.重定向错误和数据.		
		将错误重定向文件1,将输出重定向文件	2> file1 1>file2
		将标准输出和标准错误输出到同一个文件		&> file













